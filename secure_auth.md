# secure_auth

A complete guide to implementing secure authentication between a web application and server

# Key Points

- Storing authentication tokens in localStorage, sessionStorage, non-HTTP cookies (document.cookie) is unsecure and leaves us vulnerable to XSS attacks.
- HTTP-only cookies are inaccessible to frontend and mitigate XSS attacks but leave us vulnerable to CSRF attacks.
- Implement CSRF tokens to mitigate CSRF attacks.
- This approach requires the server and web application to be on the same primary domain. They can be on different subdomains.
- If we use different environments such as test, staging and production in the same primary domain, we need to have separate cookie names for them such as `test_csrf`, `staging_csrf`, `prod_csrf` otherwise the cookies will leak into each other.
- Cookie parameter configurations are as follows for localhost testing:
  - Secure
    - http: `false`
    - https: `true`
  - Samesite
    - different subdomains: `lax`
    - same subdomain and primary domain: `strict`
    - localhost: `none`
  - Max age: 1 year (CSRF and auth tokens have their own expiration)
  - Domain
    - `.example.com` for common primary domain
    - don't set for localhost
```python
def get_cookie_prefix(self):
    if self.env == "local":
        return "test"

    return self.env

def use_secure_cookie(self):
  if self.env != "local":
      return True
  return False

def get_cookie_params(self):
    params = {
        "secure": self.use_secure_cookie(),
        "samesite": self.get_samesite_cookie(),
        "max_age": 365 * 24 * 60 * 60,
    }

    if self.env != "local":
        params["domain"] = ".example.com"

    return params

def set_csrf_token_cookie(self, response: Response, csrf_token: str, session_id: str):
  # not readable by frontend
  response.set_cookie(
      key=f"{self.get_cookie_prefix()}_session_id",
      value=session_id,
      httponly=True,
      **self.get_cookie_params(),
  )

  # readable by frontend
  response.set_cookie(
      key=f"{self.get_cookie_prefix()}_csrf_token",
      value=csrf_token,
      httponly=False,
      **self.get_cookie_params(),
  )

def set_jwt_access_token(self, response: Response, token: str):
  # not readable by frontend
  response.set_cookie(
      key=f"{self.get_cookie_prefix()}_jwta",
      value=token,
      httponly=True,
      **self.get_cookie_params(),
  )

  # set expiration detail cookie (readable by frontend)
  response.set_cookie(
      key=f"{self.get_cookie_prefix()}_jwtae",
      value=str(self.TOKEN_EXPIRY),
      httponly=False,
      **self.get_cookie_params(),
  )

def set_jwt_refresh_token(self, response: Response, token: str):
    # not readable by frontend
    response.set_cookie(
        key=f"{self.get_cookie_prefix()}_jwtr",
        value=token,
        httponly=True,
        **self.get_cookie_params(),
    )

    # set expiration detail cookie (readable by frontend)
    response.set_cookie(
        key=f"{self.get_cookie_prefix()}_jwtre",
        value=str(self.REFRESH_TOKEN_EXPIRY),
        httponly=False,
        **self.get_cookie_params(),
    )
```


# Architecture
- Auth tokens are stored in HTTP-only cookies
- A CSRF token and a session_id is regularly generated by the server. The server sets the CSRF token as a non-HTTP cookie and session_id as an HTTP-only cookie.
- The expiration dates of CSRF and auth tokens are stored as separate non-HTTP cookies.
- Before each request made to the server, the web app must check if the CSRF token and auth tokens are about to expire and refresh them before hand. Implementing a locking mechanism is recommended (as shown below).
- When making any API request
  - set `credentials: "include"` (allows the server to read and write cookies on the web application)
  - include the CSRF token as a custom header `X-CSRF-Token` (double check)

# Web app setup
### Setting up a Session service
```typescript
export class SessionService implements SessionServiceInterface {
  private cookieService: CookieServiceInterface;
  private env: string;
  private API_URL: string;
  private refreshPromise: Promise<void> | null = null;

  constructor(apiUrl: string, cookieService: CookieServiceInterface) {
    this.cookieService = cookieService;
    this.API_URL = apiUrl;
    this.env = process.env.NEXT_PUBLIC_ENVIRONMENT ?? "dev";
    if (this.env === "dev") {
      this.env = "test";
    }
  }

  // Public methods
  public async generateJwtToken(): Promise<void> {}

  public async refreshJwtToken(): Promise<void> {}

  public async generateCsrfToken(): Promise<void> {}

  private async autoRefresh() {
    if (this.refreshPromise) {
      return this.refreshPromise;
    }

    this.refreshPromise = (async () => {
      try {
        const now = Date.now();
        const refreshThreshold = 5 * 60 * 1000; // 5 minutes

        const csrfExpiration = Number(
          this.cookieService.get(CookieKey.CSRF_EXP) || 0,
        );

        if (csrfExpiration && csrfExpiration - now < refreshThreshold) {
          try {
            await this.generateCsrfToken();
          } catch (error) {
            console.log(idToken);
            console.error("Error generating CSRF token", error);
          }
        }

        const jwtaExpiration = Number(
          this.cookieService.get(CookieKey.JWTA_EXP) || 0,
        );
        if (jwtaExpiration && jwtaExpiration - now < refreshThreshold) {
          await this.refreshJwtToken();
          onsole.log("JWT token refreshed");
        }
      } finally {
        // The lock is released after all sequential operations are done.
        this.refreshPromise = null;
      }
    })();

    return this.refreshPromise;
  }

  private getCsrfTokenFromCookie(): string | null {
    return this.cookieService.get(CookieKey.CSRF_TOKEN);
  }

  public async getCsrfToken(): Promise<string | null> {
    await this.autoRefresh();
    const csrfToken = this.getCsrfTokenFromCookie();
    if (!csrfToken) {
      await expireSession();
    }
    return csrfToken;
  }
}
```

# Server setup
### Setting up a Session service
```python
from fastapi import HTTPException, status, Security, Cookie, Header, Response
from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer

security = HTTPBearer(auto_error=False)

self.serializer = URLSafeTimedSerializer(self.CSRF_SECRET_KEY)

def generate_csrf_token(self, session_id: str):
    return self.serializer.dumps(session_id, salt=self.CSRF_SALT)

def verify_csrf_token(self, csrf_token: str, session_id: str):
    try:
        token_session_id = self.serializer.loads(csrf_token, salt=self.CSRF_SALT, max_age=self.CSRF_MAX_AGE)
        if token_session_id != session_id:
            raise ValueError("Invalid session")
    except Exception:
        raise HTTPException(status_code=403, detail="Invalid CSRF token")

def validate_csrf_token(
        self,
        test_session_id: str = Cookie(None),
        test_csrf_token: str = Cookie(None),

        prod_session_id: str = Cookie(None),
        prod_csrf_token: str = Cookie(None),
        csrf_token_header: str = Header(None, alias="X-CSRF-Token")
) -> bool:
    session_id = prod_session_id if self.env == "prod" else test_session_id
    csrf_token = prod_csrf_token if self.env == "prod" else test_csrf_token

    if not session_id:
        raise HTTPException(status_code=401, detail="Not authenticated")
    if not csrf_token or not csrf_token_header:
        raise HTTPException(status_code=403, detail="Missing CSRF token")

    if csrf_token != csrf_token_header:
        raise HTTPException(status_code=403, detail="CSRF mismatch")

    self.verify_csrf_token(csrf_token, session_id)
    return True

def verify_token(
        self,
        prod_jwta: str = Cookie(None),
        prod_session_id: str = Cookie(None),
        prod_csrf_token: str = Cookie(None),

        test_jwta: str = Cookie(None),
        test_session_id: str = Cookie(None),
        test_csrf_token: str = Cookie(None),

        csrf_token_header: str = Header(None, alias="X-CSRF-Token"),
        authorization: HTTPAuthorizationCredentials = Security(security) # allows access for testing/mobile apps
) -> JWTClaims:
    if authorization:
        access_token = authorization.credentials

    else:
        if self.env == "prod":
            self.validate_csrf_token(prod_session_id=prod_session_id, prod_csrf_token=prod_csrf_token, csrf_token_header=csrf_token_header)
            access_token = prod_jwta

        else:
            self.validate_csrf_token(test_session_id=test_session_id, test_csrf_token=test_csrf_token, csrf_token_header=csrf_token_header)
            access_token = test_jwta

    try:
        data = jwt.decode(access_token, self.SECRET_KEY, algorithms=[self.ALGORITHM])
        return JWTClaims(**data)
    except jwt.ExpiredSignatureError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token has expired",
            headers={"WWW-Authenticate": "Bearer"},
        )
    except jwt.InvalidTokenError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
```
